{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Documenta\u00e7\u00e3o - Data Quality","text":"<pre><code>graph TD;\nA[Configura Vari\u00e1veis] --&gt; B[Ler o Banco SQL];\nB --&gt;|Sucesso| V[Valida\u00e7\u00e3o do Schema de Entrada];\nV --&gt;|Falha| X[Alerta de Erro];\nV --&gt;|Sucesso| C[Transformar os KPIs];\nC --&gt; Y[Valida\u00e7\u00e3o do Schema de Sa\u00edda];\nY --&gt;|Falha| Z[Alerta de Erro];\nY --&gt;|Sucesso| D[Salvar no DuckDB];\n</code></pre>"},{"location":"#contrato-de-dados","title":"Contrato de dados","text":"<p>               Bases: <code>SchemaModel</code></p> <p>Esquema de valida\u00e7\u00e3o para um DataFrame de produtos.</p> <p>Attributes:</p> Name Type Description <code>id_produto</code> <code>int</code> <p>Identificador \u00fanico do produto.</p> <code>nome</code> <code>str</code> <p>Nome do produto.</p> <code>quantidade</code> <code>int</code> <p>Quantidade em estoque do produto. Deve ser no m\u00ednimo 20 e no m\u00e1ximo 200.</p> <code>preco</code> <code>float</code> <p>Pre\u00e7o do produto. Deve ser maior que 0, sem limite m\u00e1ximo.</p> <code>categoria</code> <code>str</code> <p>Categoria \u00e0 qual o produto pertence.</p> Source code in <code>app\\schemas.py</code> <pre><code>class ProdutoSchema(pa.SchemaModel):\n    \"\"\"\n    Esquema de valida\u00e7\u00e3o para um DataFrame de produtos.\n\n    Attributes:\n        id_produto (int): Identificador \u00fanico do produto.\n        nome (str): Nome do produto.\n        quantidade (int): Quantidade em estoque do produto. Deve ser no m\u00ednimo 20 e no m\u00e1ximo 200.\n        preco (float): Pre\u00e7o do produto. Deve ser maior que 0, sem limite m\u00e1ximo.\n        categoria (str): Categoria \u00e0 qual o produto pertence.\n    \"\"\"\n\n    id_produto: Series[int] = pa.Field(ge=0, description=\"Identificador \u00fanico do produto (sem limite m\u00e1ximo).\")\n    nome: Series[str] = pa.Field(nullable=False, description=\"Nome do produto.\")\n    quantidade: Series[int] = pa.Field(ge=0, description=\"Quantidade em estoque \")\n    preco: Series[float] = pa.Field(ge=0.01, description=\"Pre\u00e7o do produto (deve ser maior que 0).\")\n    categoria: Series[str] = pa.Field(nullable=False, description=\"Categoria do produto.\")\n\n    class Config:\n        coerce = True  # For\u00e7a a convers\u00e3o dos tipos\n        strict = True  # Garante que apenas colunas definidas no schema sejam aceitas\n</code></pre>"},{"location":"#ler-o-banco","title":"Ler o Banco","text":"<p>Extrai dados do banco de dados SQL usando a consulta fornecida.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>A consulta SQL para extrair dados.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>Um DataFrame do Pandas contendo os dados extra\u00eddos.</p> Source code in <code>app\\etl.py</code> <pre><code>@pa.check_output(ProdutoSchema, lazy=True)\n\ndef extrair_do_sql(query: str) -&gt; pd.DataFrame:\n    \"\"\"\n    Extrai dados do banco de dados SQL usando a consulta fornecida.\n\n    Args:\n        query: A consulta SQL para extrair dados.\n\n    Returns:\n        Um DataFrame do Pandas contendo os dados extra\u00eddos.\n    \"\"\" \n    settings = load_settings()\n\n    # Criar a string de conex\u00e3o com base nas configura\u00e7\u00f5es\n    connection_string = f\"postgresql://{settings['db_user']}:{settings['db_pass']}@{settings['db_host']}:{settings['db_port']}/{settings['db_name']}\"\n\n    # Criar engine de conex\u00e3o\n    engine = create_engine(connection_string)\n\n    with engine.connect() as conn, conn.begin():\n        df = pd.read_sql(query, conn)\n\n    return df  # Retorna o DataFrame\n</code></pre>"},{"location":"#transformar-os-kpis","title":"Transformar os KPIs","text":"Source code in <code>app\\etl.py</code> <pre><code>@pa.check_input(ProdutoSchema, lazy=True)\n@pa.check_output(ProductSchemaKPI, lazy=True)\ndef transformar(df: pd.DataFrame) -&gt; pd.DataFrame:\n    # Calcular valor_total_estoque\n    df['valor_total_estoque'] = df['quantidade'] * df['preco']\n\n    # Normalizar categoria para mai\u00fasculas\n    df['categoria_normalizada'] = df['categoria'].str.upper()\n\n    # Determinar disponibilidade\n    df['disponibilidade'] = df['quantidade'] &gt; 0\n\n    return df\n</code></pre>"},{"location":"#salvar-no-duckdb","title":"Salvar no DuckDB","text":"<p>Carrega o DataFrame no DuckDB, criando ou substituindo a tabela especificada.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>DataFrame do Pandas para ser carregado no DuckDB.</p> required <code>table_name</code> <code>str</code> <p>Nome da tabela no DuckDB onde os dados ser\u00e3o inseridos.</p> required <code>db_file</code> <code>str</code> <p>Caminho para o arquivo DuckDB. Se n\u00e3o existir, ser\u00e1 criado.</p> <code>'my_duckdb.db'</code> Source code in <code>app\\etl.py</code> <pre><code>@pa.check_input(ProductSchemaKPI, lazy=True)\ndef load_to_duckdb(df: pd.DataFrame, table_name: str, db_file: str = 'my_duckdb.db'):\n    \"\"\"\n    Carrega o DataFrame no DuckDB, criando ou substituindo a tabela especificada.\n\n    Args:\n        df: DataFrame do Pandas para ser carregado no DuckDB.\n        table_name: Nome da tabela no DuckDB onde os dados ser\u00e3o inseridos.\n        db_file: Caminho para o arquivo DuckDB. Se n\u00e3o existir, ser\u00e1 criado.\n    \"\"\"\n    # Conectar ao DuckDB. Se o arquivo n\u00e3o existir, ele ser\u00e1 criado.\n    con = duckdb.connect(database=db_file, read_only=False)\n\n    # Registrar o DataFrame como uma tabela tempor\u00e1ria\n    con.register('df_temp', df)\n\n    # Utilizar SQL para inserir os dados da tabela tempor\u00e1ria em uma tabela permanente\n    # Se a tabela j\u00e1 existir, substitui.\n    con.execute(f\"CREATE OR REPLACE TABLE {table_name} AS SELECT * FROM df_temp\")\n\n    # Fechar a conex\u00e3o\n    con.close()\n</code></pre>"}]}